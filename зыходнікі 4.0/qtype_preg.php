<?php
// This file is part of Moodle - https://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.

/**
 * Strings for component 'qtype_preg', language 'en', version '4.0'.
 *
 * @package     qtype_preg
 * @category    string
 * @copyright   1999 Martin Dougiamas and contributors
 * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

$string['accept_leaf_control'] = '';
$string['answerno'] = 'Answer {$a}';
$string['answersinstruct'] = '<p>Enter (at least one) regular expressions in the chosen notation as answers. If a correct answer is given, it should match at least one regular expression with 100% grade.</p><p>You can use placeholders like {$0} in the feedback to insert captured parts of a student\'s response. {$0} will be replaced by the whole match, {$1} with the first subpattern match etc. If the chosen engine doesn\'t support subpattern capturing you should use only {$0}.</p>';
$string['any_leaf_control'] = '';
$string['anycrlf_leaf_control'] = '';
$string['approximatematch'] = 'Typo detection';
$string['approximatematch_help'] = 'Typo detection provides match with insensitivity for some errors count. If matcher encounters errors, match become partial.';
$string['assertfailmodeasis'] = 'Fast';
$string['assertfailmodedescription'] = 'Full mode lets the finite state automata engine work 100% correctly with simple assertions and enables support of complex assertions, but it works roughtly 2 times slower than the fast mode. Fast mode may rarely yield a wrong hint in complex regexes with \\b or \\B assertions.';
$string['assertfailmodelabel'] = 'Assertion support mode';
$string['assertfailmodemerge'] = 'Full';
$string['authoring_form_charset_flags'] = 'real meaning (unified format)';
$string['authoring_form_charset_mode'] = 'Display mode for complex character classes:';
$string['authoring_form_charset_userinscription'] = 'as written in regular expressions';
$string['authoring_form_check_strings'] = 'Check the string(s)';
$string['authoring_form_edit_header'] = 'Regular expression';
$string['authoring_form_edit_header_help'] = 'Input your regex here. You\'ll see corresponding syntax tree, explaining graph and description. Click "Save changes" to commit changes in the regex.';
$string['authoring_form_graph_build'] = 'Building the graph...';
$string['authoring_form_options_header'] = 'Matching options';
$string['authoring_form_options_header_help'] = 'Here you can tune the matching. These options will be saved in the question editing form.';
$string['authoring_form_page_header'] = 'Regex constructor';
$string['authoring_form_rect_selection_mode'] = 'Rectangle selection mode';
$string['authoring_form_rect_selection_select'] = 'Select';
$string['authoring_form_testing_header'] = 'Regular expression testing';
$string['authoring_form_testing_header_help'] = 'Here you can input some strings (one per line) to test your regex. After clicking "Check the string(s)", you\'ll see results on the right: matched parts are green, unmatched parts are red. An icon shows you whether the given string matched the entire regex (green check mark) or not (red cross).';
$string['authoring_form_testing_textarea'] = 'Input strings to match (one per line)';
$string['authoring_form_text'] = 'Enter your regex here:';
$string['authoring_form_tooltip'] = 'Open regex constructor';
$string['authoring_form_tree_build'] = 'Building the tree...';
$string['backref_intersection'] = 'Using backreferences with assertions isn\'t supported yet.';
$string['backreforrecursionforapproximate'] = 'Backreferences or recursion for match with typo detection';
$string['bsr_anycrlf_leaf_control'] = '';
$string['bsr_unicode_leaf_control'] = '';
$string['c_at_end_of_pattern_node_error'] = 'Syntax error: \\c at end of pattern';
$string['callout_big_number_node_error'] = 'The number {$a->addinfo} in the callout is too big, should not be greater than 255';
$string['capital_esc_z_leaf_assert'] = 'end of the string';
$string['char_code_disallowed_node_error'] = 'Unicode code points 0xd800 ... 0xdfff are now allowed';
$string['char_code_too_big_node_error'] = 'The character code {$a->addinfo} is too big';
$string['charhintpenalty'] = 'Penalty for the next character hint';
$string['charhintpenalty_help'] = 'Penalty for getting the one-character hint. Typically will be greater than usual Moodle question penalty (which applies to any new attempt to answer question without hints). These penalties are mutually exclusive.';
$string['circumflex_leaf_assert'] = 'start of the string';
$string['collapsed_node'] = 'collapsed subexpression';
$string['commit_leaf_control'] = '';
$string['condsubexpr_assert_expected_node_error'] = 'Assertion or condition expected';
$string['condsubexpr_too_much_alter_node_error'] = 'Syntax error: too many top-level alternations in the conditional subpattern in position from {$a->colfirst} to {$a->collast}. Use parentheses if you want to include alternations in yes-expr on no-expr';
$string['condsubexpr_zero_condition_node_error'] = 'Invalid condition (?(0)';
$string['correctanswer'] = 'Correct answer';
$string['correctanswer_help'] = 'Enter a correct answer (not a regular expression) to be shown to students. If you leave it empty the matching engine will try to generate a correct answer itself, taking heed to get the closest one to the student\'s response. For now only finite state automata engine can generate correct answers.';
$string['cr_leaf_control'] = '';
$string['crlf_leaf_control'] = '';
$string['cx_should_be_ascii_node_error'] = '\\c should be followed by an ascii character';
$string['debugheading'] = 'Debug settings';
$string['defaultenginedescription'] = 'Matching engine selected by default when creating a new question';
$string['defaultenginelabel'] = 'Default matching engine';
$string['defaultlangdescription'] = 'Language selected by default when creating a new question';
$string['defaultlanglabel'] = 'Default language';
$string['defaultnotationdescription'] = 'Notation selected by default when creating a new question';
$string['defaultnotationlabel'] = 'Default notation';
$string['define_node_cond_subexpr'] = '"define"-conditional subpattern';
$string['description_accept_leaf_control'] = 'force successful subpattern match';
$string['description_any_leaf_control'] = 'newline matches any Unicode newline sequence';
$string['description_anycrlf_leaf_control'] = 'newline matches carriage return, linefeed or carriage return followed by linefeed';
$string['description_bsr_anycrlf_leaf_control'] = '\\R matches CR, LF, or CRLF';
$string['description_bsr_unicode_leaf_control'] = '\\R matches any Unicode newline sequence';
$string['description_capital_esc_z_leaf_assert'] = 'end of the string';
$string['description_char'] = '<span class="text-info" class=\'font-family:"Courier New", Courier, monospace;\'>{$a->char}</span>';
$string['description_char0'] = 'null character(NUL)';
$string['description_char1'] = 'start of header character (SOH)';
$string['description_char10'] = 'data link escape character (DLE)';
$string['description_char11'] = 'device control 1 (oft. XON) character (DC1)';
$string['description_char12'] = 'device control 2 character (DC2)';
$string['description_char13'] = 'device control 3 (oft. XOFF) character (DC3)';
$string['description_char14'] = 'device control 4 character (DC4)';
$string['description_char15'] = 'negative acknowledgement character (NAK)';
$string['description_char16'] = 'synchronous idle character (SYN)';
$string['description_char17'] = 'end of transmission block character (ETB)';
$string['description_char18'] = 'cancel character (CAN)';
$string['description_char19'] = 'end of medium character (EM)';
$string['description_char1A'] = 'substitute character (SUB)';
$string['description_char1B'] = 'escape(ESC)';
$string['description_char1C'] = 'file separator character (FS)';
$string['description_char1D'] = 'group separator character (GS)';
$string['description_char1E'] = 'record separator character (RS)';
$string['description_char1F'] = 'unit separator character (US)';
$string['description_char2'] = 'start of text character(STX)';
$string['description_char20'] = 'space';
$string['description_char2002'] = 'en space';
$string['description_char2003'] = 'em space';
$string['description_char2009'] = 'thin space';
$string['description_char200C'] = 'zero width non-joiner';
$string['description_char200D'] = 'zero width joiner';
$string['description_char3'] = 'end of text character(ETX)';
$string['description_char4'] = 'end of transmission character(EOT)';
$string['description_char5'] = 'enquiry character(ENQ)';
$string['description_char6'] = 'acknowledgement character(ACK)';
$string['description_char7'] = 'alarm character(BEL)';
$string['description_char7F'] = 'delete character (DEL)';
$string['description_char8'] = 'backspace character(BS)';
$string['description_char9'] = 'tabulation(HT)';
$string['description_charA'] = 'line feed(LF)';
$string['description_charA0'] = 'non-breaking space';
$string['description_charAD'] = 'soft hyphen character';
$string['description_charB'] = 'vertical tabulation(VT)';
$string['description_charC'] = 'form feed(FF)';
$string['description_charD'] = 'carriage return character(CR)';
$string['description_charE'] = 'shift out character (SO)';
$string['description_charF'] = 'shift in character (SI)';
$string['description_char_16value'] = 'character with code 0x{$a->code}';
$string['description_charflag_Arabic'] = 'Arabic character';
$string['description_charflag_Arabic_neg'] = 'not Arabic character';
$string['description_charflag_Armenian'] = 'Armenian character';
$string['description_charflag_Armenian_neg'] = 'not Armenian character';
$string['description_charflag_Avestan'] = 'Avestan character';
$string['description_charflag_Avestan_neg'] = 'not Avestan character';
$string['description_charflag_Balinese'] = 'Balinese character';
$string['description_charflag_Balinese_neg'] = 'not Balinese character';
$string['description_charflag_Bamum'] = 'Bamum character';
$string['description_charflag_Bamum_neg'] = 'not Bamum character';
$string['description_charflag_Bengali'] = 'Bengali character';
$string['description_charflag_Bengali_neg'] = 'not Bengali character';
$string['description_charflag_Bopomofo'] = 'Bopomofo character';
$string['description_charflag_Bopomofo_neg'] = 'not Bopomofo character';
$string['description_charflag_Braille'] = 'Braille character';
$string['description_charflag_Braille_neg'] = 'not Braille character';
$string['description_charflag_Buginese'] = 'Buginese character';
$string['description_charflag_Buginese_neg'] = 'not Buginese character';
$string['description_charflag_Buhid'] = 'Buhid character';
$string['description_charflag_Buhid_neg'] = 'not Buhid character';
$string['description_charflag_C'] = 'other Unicode property';
$string['description_charflag_C_neg'] = 'not other Unicode property';
$string['description_charflag_Canadian_Aboriginal'] = 'Canadian Aboriginal character';
$string['description_charflag_Canadian_Aboriginal_neg'] = 'not Canadian Aboriginal character';
$string['description_charflag_Carian'] = 'Carian character';
$string['description_charflag_Carian_neg'] = 'not Carian character';
$string['description_charflag_Cc'] = 'control';
$string['description_charflag_Cc_neg'] = 'not control';
$string['description_charflag_Cf'] = 'format';
$string['description_charflag_Cf_neg'] = 'not format';
$string['description_charflag_Cham'] = 'Cham character';
$string['description_charflag_Cham_neg'] = 'not Cham character';
$string['description_charflag_Cherokee'] = 'Cherokee character';
$string['description_charflag_Cherokee_neg'] = 'not Cherokee character';
$string['description_charflag_Cn'] = 'unassigned';
$string['description_charflag_Cn_neg'] = 'not unassigned';
$string['description_charflag_Co'] = 'private use';
$string['description_charflag_Co_neg'] = 'not private use';
$string['description_charflag_Common'] = 'Common character';
$string['description_charflag_Common_neg'] = 'not Common character';
$string['description_charflag_Coptic'] = 'Coptic character';
$string['description_charflag_Coptic_neg'] = 'not Coptic character';
$string['description_charflag_Cs'] = 'surrogate';
$string['description_charflag_Cs_neg'] = 'not surrogate';
$string['description_charflag_Cuneiform'] = 'Cuneiform character';
$string['description_charflag_Cuneiform_neg'] = 'not Cuneiform character';
$string['description_charflag_Cypriot'] = 'Cypriot character';
$string['description_charflag_Cypriot_neg'] = 'not Cypriot character';
$string['description_charflag_Cyrillic'] = 'Cyrillic character';
$string['description_charflag_Cyrillic_neg'] = 'not Cyrillic character';
$string['description_charflag_Deseret'] = 'Deseret character';
$string['description_charflag_Deseret_neg'] = 'not Deseret character';
$string['description_charflag_Devanagari'] = 'Devanagari character';
$string['description_charflag_Devanagari_neg'] = 'not Devanagari character';
$string['description_charflag_Egyptian_Hieroglyphs'] = 'Egyptian Hieroglyphs character';
$string['description_charflag_Egyptian_Hieroglyphs_neg'] = 'not Egyptian Hieroglyphs character';
$string['description_charflag_Ethiopic'] = 'Ethiopic character';
$string['description_charflag_Ethiopic_neg'] = 'not Ethiopic character';
$string['description_charflag_Georgian'] = 'Georgian character';
$string['description_charflag_Georgian_neg'] = 'not Georgian character';
$string['description_charflag_Glagolitic'] = 'Glagolitic character';
$string['description_charflag_Glagolitic_neg'] = 'not Glagolitic character';
$string['description_charflag_Gothic'] = 'Gothic character';
$string['description_charflag_Gothic_neg'] = 'not Gothic character';
$string['description_charflag_Greek'] = 'Greek character';
$string['description_charflag_Greek_neg'] = 'not Greek character';
$string['description_charflag_Gujarati'] = 'Gujarati character';
$string['description_charflag_Gujarati_neg'] = 'not Gujarati character';
$string['description_charflag_Gurmukhi'] = 'Gurmukhi character';
$string['description_charflag_Gurmukhi_neg'] = 'not Gurmukhi character';
$string['description_charflag_Han'] = 'Han character';
$string['description_charflag_Han_neg'] = 'not Han character';
$string['description_charflag_Hangul'] = 'Hangul character';
$string['description_charflag_Hangul_neg'] = 'not Hangul character';
$string['description_charflag_Hanunoo'] = 'Hanunoo character';
$string['description_charflag_Hanunoo_neg'] = 'not Hanunoo character';
$string['description_charflag_Hebrew'] = 'Hebrew character';
$string['description_charflag_Hebrew_neg'] = 'not Hebrew character';
$string['description_charflag_Hiragana'] = 'Hiragana character';
$string['description_charflag_Hiragana_neg'] = 'not Hiragana character';
$string['description_charflag_Imperial_Aramaic'] = 'Imperial Aramaic character';
$string['description_charflag_Imperial_Aramaic_neg'] = 'not Imperial Aramaic character';
$string['description_charflag_Inherited'] = 'Inherited character';
$string['description_charflag_Inherited_neg'] = 'not Inherited character';
$string['description_charflag_Inscriptional_Pahlavi'] = 'Inscriptional Pahlavi character';
$string['description_charflag_Inscriptional_Pahlavi_neg'] = 'not Inscriptional Pahlavi character';
$string['description_charflag_Inscriptional_Parthian'] = 'Inscriptional Parthian character';
$string['description_charflag_Inscriptional_Parthian_neg'] = 'not Inscriptional Parthian character';
$string['description_charflag_Javanese'] = 'Javanese character';
$string['description_charflag_Javanese_neg'] = 'not Javanese character';
$string['description_charflag_Kaithi'] = 'Kaithi character';
$string['description_charflag_Kaithi_neg'] = 'not Kaithi character';
$string['description_charflag_Kannada'] = 'Kannada character';
$string['description_charflag_Kannada_neg'] = 'not Kannada character';
$string['description_charflag_Katakana'] = 'Katakana character';
$string['description_charflag_Katakana_neg'] = 'not Katakana character';
$string['description_charflag_Kayah_Li'] = 'Kayah Li character';
$string['description_charflag_Kayah_Li_neg'] = 'not Kayah Li character';
$string['description_charflag_Kharoshthi'] = 'Kharoshthi character';
$string['description_charflag_Kharoshthi_neg'] = 'not Kharoshthi character';
$string['description_charflag_Khmer'] = 'Khmer character';
$string['description_charflag_Khmer_neg'] = 'not Khmer character';
$string['description_charflag_L'] = 'letter';
$string['description_charflag_L_neg'] = 'not letter';
$string['description_charflag_Lao'] = 'Lao character';
$string['description_charflag_Lao_neg'] = 'not Lao character';
$string['description_charflag_Latin'] = 'Latin character';
$string['description_charflag_Latin_neg'] = 'not Latin character';
$string['description_charflag_Lepcha'] = 'Lepcha character';
$string['description_charflag_Lepcha_neg'] = 'not Lepcha character';
$string['description_charflag_Limbu'] = 'Limbu character';
$string['description_charflag_Limbu_neg'] = 'not Limbu character';
$string['description_charflag_Linear_B'] = 'Linear B character';
$string['description_charflag_Linear_B_neg'] = 'not Linear B character';
$string['description_charflag_Lisu'] = 'Lisu character';
$string['description_charflag_Lisu_neg'] = 'not Lisu character';
$string['description_charflag_Ll'] = 'lower case letter';
$string['description_charflag_Ll_neg'] = 'not lower case letter';
$string['description_charflag_Lm'] = 'modifier letter';
$string['description_charflag_Lm_neg'] = 'not modifier letter';
$string['description_charflag_Lo'] = 'other letter';
$string['description_charflag_Lo_neg'] = 'not other letter';
$string['description_charflag_Lt'] = 'title case letter';
$string['description_charflag_Lt_neg'] = 'not title case letter';
$string['description_charflag_Lu'] = 'upper case letter';
$string['description_charflag_Lu_neg'] = 'not upper case letter';
$string['description_charflag_Lycian'] = 'Lycian character';
$string['description_charflag_Lycian_neg'] = 'not Lycian character';
$string['description_charflag_Lydian'] = 'Lydian character';
$string['description_charflag_Lydian_neg'] = 'not Lydian character';
$string['description_charflag_M'] = 'mark';
$string['description_charflag_M_neg'] = 'not mark';
$string['description_charflag_Malayalam'] = 'Malayalam character';
$string['description_charflag_Malayalam_neg'] = 'not Malayalam character';
$string['description_charflag_Mc'] = 'spacing mark';
$string['description_charflag_Mc_neg'] = 'not spacing mark';
$string['description_charflag_Me'] = 'enclosing mark';
$string['description_charflag_Me_neg'] = 'not enclosing mark';
$string['description_charflag_Meetei_Mayek'] = 'Meetei Mayek character';
$string['description_charflag_Meetei_Mayek_neg'] = 'not Meetei Mayek character';
$string['description_charflag_Mn'] = 'non-spacing mark';
$string['description_charflag_Mn_neg'] = 'not non-spacing mark';
$string['description_charflag_Mongolian'] = 'Mongolian character';
$string['description_charflag_Mongolian_neg'] = 'not Mongolian character';
$string['description_charflag_Myanmar'] = 'Myanmar character';
$string['description_charflag_Myanmar_neg'] = 'not Myanmar character';
$string['description_charflag_N'] = 'number';
$string['description_charflag_N_neg'] = 'not number';
$string['description_charflag_Nd'] = 'decimal number';
$string['description_charflag_Nd_neg'] = 'not decimal number';
$string['description_charflag_New_Tai_Lue'] = 'New Tai Lue character';
$string['description_charflag_New_Tai_Lue_neg'] = 'not New Tai Lue character';
$string['description_charflag_Nko'] = 'Nko character';
$string['description_charflag_Nko_neg'] = 'not Nko character';
$string['description_charflag_Nl'] = 'letter number';
$string['description_charflag_Nl_neg'] = 'not letter number';
$string['description_charflag_No'] = 'other number';
$string['description_charflag_No_neg'] = 'not other number';
$string['description_charflag_Ogham'] = 'Ogham character';
$string['description_charflag_Ogham_neg'] = 'not Ogham character';
$string['description_charflag_Ol_Chiki'] = 'Ol_Chiki character';
$string['description_charflag_Ol_Chiki_neg'] = 'not Ol_Chiki character';
$string['description_charflag_Old_Italic'] = 'Old Italic character';
$string['description_charflag_Old_Italic_neg'] = 'not Old Italic character';
$string['description_charflag_Old_Persian'] = 'Old Persian character';
$string['description_charflag_Old_Persian_neg'] = 'not Old Persian character';
$string['description_charflag_Old_South_Arabian'] = 'Old South_Arabian character';
$string['description_charflag_Old_South_Arabian_neg'] = 'not Old South_Arabian character';
$string['description_charflag_Old_Turkic'] = 'Old_Turkic character';
$string['description_charflag_Old_Turkic_neg'] = 'not Old_Turkic character';
$string['description_charflag_Oriya'] = 'Oriya character';
$string['description_charflag_Oriya_neg'] = 'not Oriya character';
$string['description_charflag_Osmanya'] = 'Osmanya character';
$string['description_charflag_Osmanya_neg'] = 'not Osmanya character';
$string['description_charflag_P'] = 'punctuation';
$string['description_charflag_P_neg'] = 'not punctuation';
$string['description_charflag_Pc'] = 'connector punctuation';
$string['description_charflag_Pc_neg'] = 'not connector punctuation';
$string['description_charflag_Pd'] = 'dash punctuation';
$string['description_charflag_Pd_neg'] = 'not dash punctuation';
$string['description_charflag_Pe'] = 'close punctuation';
$string['description_charflag_Pe_neg'] = 'not close punctuation';
$string['description_charflag_Pf'] = 'final punctuation';
$string['description_charflag_Pf_neg'] = 'not final punctuation';
$string['description_charflag_Phags_Pa'] = 'Phags_Pa character';
$string['description_charflag_Phags_Pa_neg'] = 'not Phags_Pa character';
$string['description_charflag_Phoenician'] = 'Phoenician character';
$string['description_charflag_Phoenician_neg'] = 'not Phoenician character';
$string['description_charflag_Pi'] = 'initial punctuation';
$string['description_charflag_Pi_neg'] = 'not initial punctuation';
$string['description_charflag_Po'] = 'other punctuation';
$string['description_charflag_Po_neg'] = 'not other punctuation';
$string['description_charflag_Ps'] = 'open punctuation';
$string['description_charflag_Ps_neg'] = 'not open punctuation';
$string['description_charflag_Rejang'] = 'Rejang character';
$string['description_charflag_Rejang_neg'] = 'not Rejang character';
$string['description_charflag_Runic'] = 'Runic character';
$string['description_charflag_Runic_neg'] = 'not Runic character';
$string['description_charflag_S'] = 'symbol';
$string['description_charflag_S_neg'] = 'not symbol';
$string['description_charflag_Samaritan'] = 'Samaritan character';
$string['description_charflag_Samaritan_neg'] = 'not Samaritan character';
$string['description_charflag_Saurashtra'] = 'Saurashtra character';
$string['description_charflag_Saurashtra_neg'] = 'not Saurashtra character';
$string['description_charflag_Sc'] = 'currency symbol';
$string['description_charflag_Sc_neg'] = 'not currency symbol';
$string['description_charflag_Shavian'] = 'Shavian character';
$string['description_charflag_Shavian_neg'] = 'not Shavian character';
$string['description_charflag_Sinhala'] = 'Sinhala character';
$string['description_charflag_Sinhala_neg'] = 'not Sinhala character';
$string['description_charflag_Sk'] = 'modifier symbol';
$string['description_charflag_Sk_neg'] = 'not modifier symbol';
$string['description_charflag_Sm'] = 'mathematical symbol';
$string['description_charflag_Sm_neg'] = 'not mathematical symbol';
$string['description_charflag_So'] = 'other symbol';
$string['description_charflag_So_neg'] = 'not other symbol';
$string['description_charflag_Sundanese'] = 'Sundanese character';
$string['description_charflag_Sundanese_neg'] = 'not Sundanese character';
$string['description_charflag_Syloti_Nagri'] = 'Syloti_Nagri character';
$string['description_charflag_Syloti_Nagri_neg'] = 'not Syloti_Nagri character';
$string['description_charflag_Syriac'] = 'Syriac character';
$string['description_charflag_Syriac_neg'] = 'not Syriac character';
$string['description_charflag_Tagalog'] = 'Tagalog character';
$string['description_charflag_Tagalog_neg'] = 'not Tagalog character';
$string['description_charflag_Tagbanwa'] = 'Tagbanwa character';
$string['description_charflag_Tagbanwa_neg'] = 'not Tagbanwa character';
$string['description_charflag_Tai_Le'] = 'Tai_Le character';
$string['description_charflag_Tai_Le_neg'] = 'not Tai_Le character';
$string['description_charflag_Tai_Tham'] = 'Tai_Tham character';
$string['description_charflag_Tai_Tham_neg'] = 'not Tai_Tham character';
$string['description_charflag_Tai_Viet'] = 'Tai_Viet character';
$string['description_charflag_Tai_Viet_neg'] = 'not Tai_Viet character';
$string['description_charflag_Tamil'] = 'Tamil character';
$string['description_charflag_Tamil_neg'] = 'not Tamil character';
$string['description_charflag_Telugu'] = 'Telugu character';
$string['description_charflag_Telugu_neg'] = 'not Telugu character';
$string['description_charflag_Thaana'] = 'Thaana character';
$string['description_charflag_Thaana_neg'] = 'not Thaana character';
$string['description_charflag_Thai'] = 'Thai character';
$string['description_charflag_Thai_neg'] = 'not Thai character';
$string['description_charflag_Tibetan'] = 'Tibetan character';
$string['description_charflag_Tibetan_neg'] = 'not Tibetan character';
$string['description_charflag_Tifinagh'] = 'Tifinagh character';
$string['description_charflag_Tifinagh_neg'] = 'not Tifinagh character';
$string['description_charflag_Ugaritic'] = 'Ugaritic character';
$string['description_charflag_Ugaritic_neg'] = 'not Ugaritic character';
$string['description_charflag_Vai'] = 'Vai character';
$string['description_charflag_Vai_neg'] = 'not Vai character';
$string['description_charflag_Xan'] = 'any alphanumeric character';
$string['description_charflag_Xan_neg'] = 'not any alphanumeric character';
$string['description_charflag_Xps'] = 'any POSIX space character';
$string['description_charflag_Xps_neg'] = 'not any POSIX space character';
$string['description_charflag_Xsp'] = 'any Perl space character';
$string['description_charflag_Xsp_neg'] = 'not any Perl space character';
$string['description_charflag_Xwd'] = 'any Perl "word" character';
$string['description_charflag_Xwd_neg'] = 'not any Perl "word" character';
$string['description_charflag_Yi'] = 'Yi character';
$string['description_charflag_Yi_neg'] = 'not Yi character';
$string['description_charflag_Z'] = 'separator';
$string['description_charflag_Z_neg'] = 'not separator';
$string['description_charflag_Zl'] = 'line separator';
$string['description_charflag_Zl_neg'] = 'not line separator';
$string['description_charflag_Zp'] = 'paragraph separator';
$string['description_charflag_Zp_neg'] = 'not paragraph separator';
$string['description_charflag_Zs'] = 'space separator';
$string['description_charflag_Zs_neg'] = 'not space separator';
$string['description_charflag_alnum'] = 'a letter or digit';
$string['description_charflag_alnum_neg'] = 'not a letter and not digit';
$string['description_charflag_alpha'] = 'a letter';
$string['description_charflag_alpha_neg'] = 'not a letter';
$string['description_charflag_ascii'] = 'a character with codes 0-127';
$string['description_charflag_ascii_neg'] = 'not a character with codes 0-127';
$string['description_charflag_blank'] = 'a space or tab only';
$string['description_charflag_blank_neg'] = 'not a space and not tab';
$string['description_charflag_cntrl'] = 'a control character';
$string['description_charflag_cntrl_neg'] = 'not a control character';
$string['description_charflag_digit'] = 'a decimal digit';
$string['description_charflag_digit_neg'] = 'not a decimal digit';
$string['description_charflag_dot'] = 'any character';
$string['description_charflag_graph'] = 'a printing character (excluding space)';
$string['description_charflag_graph_neg'] = 'not a printing character (excluding space)';
$string['description_charflag_lower'] = 'a lower case letter';
$string['description_charflag_lower_neg'] = 'not a lower case letter';
$string['description_charflag_print'] = 'a printing character (including space)';
$string['description_charflag_print_neg'] = 'not a printing character (including space)';
$string['description_charflag_punct'] = 'a printing character (excluding letters and digits and space)';
$string['description_charflag_punct_neg'] = 'not a printing character (excluding letters and digits and space)';
$string['description_charflag_slashd'] = 'a decimal digit';
$string['description_charflag_slashd_neg'] = 'not a decimal digit';
$string['description_charflag_slashh'] = 'a horizontal white space character';
$string['description_charflag_slashh_neg'] = 'not a horizontal white space character';
$string['description_charflag_slashs'] = 'a white space';
$string['description_charflag_slashs_neg'] = 'not a white space';
$string['description_charflag_slashv'] = 'a vertical white space character';
$string['description_charflag_slashv_neg'] = 'not a vertical white space character';
$string['description_charflag_slashw'] = 'a word character';
$string['description_charflag_slashw_neg'] = 'not a word character';
$string['description_charflag_space'] = 'a white space';
$string['description_charflag_space_neg'] = 'not a white space';
$string['description_charflag_upper'] = 'an upper case letter';
$string['description_charflag_upper_neg'] = 'not an upper case letter';
$string['description_charflag_word'] = 'a word character';
$string['description_charflag_word_neg'] = 'not a word character';
$string['description_charflag_xdigit'] = 'a hexadecimal digit';
$string['description_charflag_xdigit_neg'] = 'not a hexadecimal digit';
$string['description_charset'] = 'one of the following characters: {$a->characters};';
$string['description_charset_neg'] = 'any character except the following: {$a->characters};';
$string['description_charset_neg_one'] = 'not {$a->characters}';
$string['description_charset_range'] = 'any character {$a}';
$string['description_circumflex_leaf_assert'] = 'start of the string';
$string['description_commit_leaf_control'] = 'if the rest of the pattern does not match - overall failure, no advance of starting point';
$string['description_cr_leaf_control'] = 'newline matches carriage return only';
$string['description_crlf_leaf_control'] = 'newline matches carriage return followed by linefeed';
$string['description_define_node_cond_subexpr'] = 'definition of {$a->firstoperand}';
$string['description_dollar_leaf_assert'] = 'end of the string';
$string['description_duplicate_node_subexpr'] = 'grouping (reset group numbers for capturing groups in each alternation): [ {$a->firstoperand} ]';
$string['description_empty_leaf_meta'] = 'nothing';
$string['description_errorafter'] = '</span>';
$string['description_errorbefore'] = '<span style="color:red">';
$string['description_esc_a_leaf_assert'] = 'start of the string';
$string['description_esc_b_leaf_assert'] = 'a word boundary';
$string['description_esc_b_leaf_assert_neg'] = 'not a word boundary';
$string['description_esc_g_leaf_assert'] = 'first matching position in the string';
$string['description_fail_leaf_control'] = 'force fail';
$string['description_grouping_node_subexpr'] = 'grouping: [ {$a->firstoperand} ]';
$string['description_leaf_backref'] = 'text matched by subpattern #{$a}';
$string['description_leaf_backref_name'] = 'text matched by subpattern "{$a}"';
$string['description_leaf_options'] = '{$a}:';
$string['description_leaf_subexpr_call'] = 'call of the subpattern #{$a}';
$string['description_leaf_subexpr_call_all'] = 'call of the whole regular expression';
$string['description_leaf_subexpr_call_all_recursive'] = 'recursive call of the whole regular expression';
$string['description_leaf_subexpr_call_name'] = 'call of the subpattern "{$a}"';
$string['description_leaf_subexpr_call_name_recursive'] = 'recursive call of the subpattern "{$a}"';
$string['description_leaf_subexpr_call_recursive'] = 'recursive call of the subpattern #{$a}';
$string['description_leaf_template'] = 'template without params';
$string['description_lf_leaf_control'] = 'newline matches linefeed only';
$string['description_mark_name_leaf_control'] = 'set name to {$a->name} to be passed back';
$string['description_nla_node_assert'] = 'further text should not match: [{$a->firstoperand}]';
$string['description_nla_node_assert_cond'] = 'further text does not match: [{$a->firstoperand}]';
$string['description_nlb_node_assert'] = 'preceding text should not match: [{$a->firstoperand}]';
$string['description_nlb_node_assert_cond'] = 'preceding text does not match: [{$a->firstoperand}]';
$string['description_no_start_opt_leaf_control'] = 'no start-match optimization';
$string['description_node_alt'] = '{$a->firstoperand} or {$a->secondoperand}';
$string['description_node_alt_wcomma'] = '{$a->firstoperand} or {$a->secondoperand}';
$string['description_node_concat'] = '{$a->firstoperand} then {$a->secondoperand}';
$string['description_node_concat_and'] = '{$a->firstoperand} and {$a->secondoperand}';
$string['description_node_concat_short'] = '{$a->firstoperand}{$a->secondoperand}';
$string['description_node_concat_space'] = '{$a->firstoperand} {$a->secondoperand}';
$string['description_node_concat_wcomma'] = '{$a->firstoperand} then {$a->secondoperand}';
$string['description_node_cond_subexpr'] = 'if {$a->cond} then check: [{$a->firstoperand}]{$a->else}';
$string['description_node_cond_subexpr_else'] = 'else check: [{$a->secondoperand}]';
$string['description_node_finite_quant'] = '{$a->firstoperand} repeated from {$a->leftborder} to {$a->rightborder} times{$a->greedy}';
$string['description_node_finite_quant_0'] = '{$a->firstoperand} repeated no more than {$a->rightborder} times or missing{$a->greedy}';
$string['description_node_finite_quant_01'] = '{$a->firstoperand} may be missing{$a->greedy}';
$string['description_node_finite_quant_1'] = '{$a->firstoperand} repeated no more than {$a->rightborder} times{$a->greedy}';
$string['description_node_finite_quant_borders_err'] = '(incorrect quantifier borders)';
$string['description_node_finite_quant_strict'] = '{$a->firstoperand} repeated {$a->leftborder} times{$a->greedy}';
$string['description_node_infinite_quant'] = '{$a->firstoperand} repeated at least {$a->leftborder} times{$a->greedy}';
$string['description_node_infinite_quant_0'] = '{$a->firstoperand} repeated any number of times or missing{$a->greedy}';
$string['description_node_infinite_quant_1'] = '{$a->firstoperand} repeated any number of times{$a->greedy}';
$string['description_node_template'] = 'template with params';
$string['description_onceonly_node_subexpr'] = 'once checked subpattern #{$a->number}: [ {$a->firstoperand} ]';
$string['description_onceonly_node_subexpr_name'] = 'once checked subpattern "{$a->name} #{$a->number}": [ {$a->firstoperand} ]';
$string['description_operand'] = 'operand';
$string['description_option_J'] = 'allow duplicate names';
$string['description_option_U'] = 'quantifiers ungreedy by default';
$string['description_option_i'] = 'caseless';
$string['description_option_m'] = 'multiline matching';
$string['description_option_s'] = 'dot metacharacter matches \\n';
$string['description_option_x'] = 'white spaces in expression was ignored';
$string['description_pla_node_assert'] = 'further text should match: [{$a->firstoperand}]';
$string['description_pla_node_assert_cond'] = 'further text matches: [{$a->firstoperand}]';
$string['description_plb_node_assert'] = 'preceding text should match: [{$a->firstoperand}]';
$string['description_plb_node_assert_cond'] = 'preceding text matches: [{$a->firstoperand}]';
$string['description_prune_leaf_control'] = 'if the rest of the pattern does not match - advance to next starting character';
$string['description_quant_greedy'] = '';
$string['description_quant_lazy'] = '(lazy quantifier)';
$string['description_quant_possessive'] = '(possessive quantifier)';
$string['description_range'] = 'from {$a->start} to {$a->end}';
$string['description_recursion_node_cond_subexpr'] = 'the pattern #{$a->number} is in recursive matching';
$string['description_recursion_node_cond_subexpr_all'] = 'the whole pattern is in recursive matching';
$string['description_recursion_node_cond_subexpr_name'] = 'the pattern "{$a->name}" is in recursive matching';
$string['description_skip_leaf_control'] = 'if the rest of the pattern does not match - advance to current matching position';
$string['description_skip_name_leaf_control'] = 'if the rest of the pattern does not match - advance to (*MARK:{$a})';
$string['description_small_esc_z_leaf_assert'] = 'end of the string';
$string['description_subexpr_node_cond_subexpr'] = 'the subpattern #{$a->number} has been successfully matched';
$string['description_subexpr_node_cond_subexpr_name'] = 'the subpattern "{$a->name}" has been successfully matched';
$string['description_subexpr_node_cond_subexpr_wrapper'] = 'if {$a->cond} then check: [{$a->firstoperand}]{$a->else}';
$string['description_subexpr_node_subexpr'] = 'subpattern #{$a->number}: [ {$a->firstoperand} ]';
$string['description_subexpr_node_subexpr_name'] = 'subpattern "{$a->name}" #{$a->number}: [ {$a->firstoperand} ]';
$string['description_template_brackets_opt'] = 'text in square brackets or without';
$string['description_template_brackets_req'] = 'text in square brackets';
$string['description_template_custom_parens_opt'] = 'text in optional custom brackets or without';
$string['description_template_custom_parens_req'] = 'text in optional custom brackets';
$string['description_template_integer'] = 'any number including + or -';
$string['description_template_parens_opt'] = 'text in round parentheses or without';
$string['description_template_parens_req'] = 'text in round parentheses';
$string['description_template_word'] = 'any word';
$string['description_then_leaf_control'] = 'if the rest of the pattern does not match - backtrack to next alternation';
$string['description_tool'] = 'Description';
$string['description_tool_help'] = 'Here you can see a description of your regular expression. Pressing the node of the tree highlights the corresponding subgraph and also marks the corresponding part of the description with a yellow color.';
$string['description_ucp_leaf_control'] = 'PCRE_UCP';
$string['description_unsetoption_J'] = 'disallow duplicate names';
$string['description_unsetoption_U'] = 'quantifiers greedy by default';
$string['description_unsetoption_i'] = 'case sensitive';
$string['description_unsetoption_m'] = 'not multiline matching';
$string['description_unsetoption_s'] = 'dot metacharacter does not match \\n';
$string['description_unsetoption_x'] = 'white spaces in expression was not ignored';
$string['description_utf16_leaf_control'] = 'UTF-16 mode';
$string['description_utf8_leaf_control'] = 'UTF-8 mode';
$string['different_subexpr_names_node_error'] = 'Different subpattern names for subpatterns of the same number';
$string['dollar_leaf_assert'] = 'end of the string';
$string['doterror'] = 'Can\'t draw {$a->name} for this regex';
$string['duplicate_subexpr_names_node_error'] = 'Two named subpatterns have the same name';
$string['empty_fa'] = 'No string can be matched by this regular expression (finite automaton is empty).';
$string['empty_leaf_meta'] = 'emptiness';
$string['engine'] = 'Matching engine';
$string['engine_heading_descriptions'] = 'Matching regular expressions can be time and memory consuming. These settings allow you to control limits of time and memory usage by the matching engines. Increase them when you get messages that the regular expression is too complex, but do mind your server\'s performance (you may also want to increase PHP time and memory limits). Decrease them if you get blank page when saving or running a preg question.';
$string['engine_help'] = '<p>There is no \'best\' matching engine, so you can choose the engine that fits the particular question best.</p><p>Native <b>PHP preg matching engine</b> works using preg_match() function from PHP language. It\'s almost 100% bug-free and able to work with full PCRE syntax, but can\'t support advanced features (showing partial matches and hinting).</p><p><b>FA matching engine</b> uses custom matching code. It supports partial matching and hinting, but don\'t support lookaround assertions (you\'ll be notified when trying to save a question with unsupported expressions) and potentially can contain bugs.</p><p>If the difference between engines is too hard for you, just try them all to see how their capabilities suit your needs. If one engine fails in a question then try another engines to see if they can handle it better.</p><p>FA engine is probably the best choice if you don\'t use lookaround assertions.</p>';
$string['error_PCREincorrectregex'] = 'Incorrect regular expression - syntax error! Consult <a href="http://pcre.org/pcre.txt">PCRE documentation</a> for more information.';
$string['error_duringauthoringtool'] = 'There were errors while trying to build {$a}:';
$string['error_infiniterecursion'] = 'Regex contains infinite recursion';
$string['esc_a_leaf_assert'] = 'start of the string';
$string['esc_b_leaf_assert'] = 'a word boundary';
$string['esc_g_leaf_assert'] = 'first matching position in the string';
$string['exactmatch'] = 'Exact matching';
$string['exactmatch_help'] = '<p>By default regular expression matching returns true if there is at least one match in the given string (answer). Exact matching means that the match must be the entire string.</p><p>Set this to Yes, if you write regular expressions for full student\'s answers. Setting this to No gives you additional flexibility: you can specify an answer with low (or zero) grade to catch common errors and give comments on them. You still can specify exact matches for some of your regular expressions if you start them with ^ and end with $.</p>';
$string['explain_any_char'] = 'Any character from';
$string['explain_any_char_except'] = 'Any character except';
$string['explain_begin'] = 'begin';
$string['explain_define'] = 'TODO';
$string['explain_end'] = 'end';
$string['explain_false'] = 'false';
$string['explain_parameter'] = 'parameter';
$string['explain_true'] = 'true';
$string['explain_unknow_meta'] = 'unknown meta';
$string['explain_unknow_template'] = 'unknow template';
$string['explaining_graph_tool'] = 'Explaining graph';
$string['explaining_graph_tool_help'] = 'Here you can see an explaining graph. Pressing the node of the tree marks the corresponding subgraph with a dark green rectangle. You can also select multiple nodes at once inside a rectangle by enabling the Rectangle selection mode checkbox.';
$string['fa_matcher'] = 'Finite state automata';
$string['fa_settings_heading'] = 'Finite state automata engine settings';
$string['fa_simulation_state_limit'] = 'Automata simulation limit: states';
$string['fa_simulation_state_limit_description'] = 'When matching a string with a regex containing backreferences or recurion, one FA state can be reached using different paths. This means that there are several "simulation states" created for one "structural state". This settings lets you control the overall count of such simulation states.';
$string['fa_state_limit'] = 'Automata size limit: states';
$string['fa_state_limit_description'] = 'Max number of states in FA. Tunes time and memory limits for the FA engine when matching complex regexes.';
$string['fa_transition_limit'] = 'Automata size limit: transitions';
$string['fa_transition_limit_description'] = 'Max number of transitions in FA. Tunes time and memory limits for the FA engine when matching complex regexes.';
$string['fail_leaf_control'] = '';
$string['greedyquant'] = 'Greedy quantifiers';
$string['grouping_node_subexpr'] = 'grouping';
$string['groupspaircountoverlimit'] = 'Possible count of groups pairs at single step of automata equivalence check algorithm overflowed. This limit is necessary to protect from long duration of comparison. Ask your site administrator to change settings if it is necessary.';
$string['hintcolouredstring'] = 'matched part of the response';
$string['hintgradeborder'] = 'Hint grade border';
$string['hintgradeborder_help'] = 'Answers with the grade less than the hint grade border won\'t be used in hinting.';
$string['hinthowtofixpic'] = 'how to fix answer';
$string['hinting'] = 'Hinting options';
$string['hinting_help'] = 'Hinting options allows you to set availability and penalties for various hints.';
$string['hintnextchar'] = 'next correct character';
$string['hintnextlexem'] = 'next correct {$a}';
$string['howtofixpichintpenalty'] = 'Penalty for how to fix picture hiniting';
$string['howtofixpichintpenalty_help'] = 'Penalty for how to fix picture hiniting';
$string['incorrect_charset_range_node_error'] = 'Incorrect character range in position from  {$a->colfirst} to {$a->collast}: the left character is "greater" than the right one';
$string['incorrect_quant_range_node_error'] = 'Incorrect quantifier range in position from  {$a->colfirst} to {$a->collast}: the left border is greater than the right one';
$string['langselect'] = 'Language';
$string['langselect_help'] = 'For next lexeme hint you should choose a language, which is used to break answers down to lexemes. Each language has it own rules for lexemes. Languages are defined using \'Formal languages block\'';
$string['lazyquant'] = 'Lazy quantifiers';
$string['lazyquantforapproximate'] = 'Lazy quantifiers for approximate match with typo detection';
$string['leaf_assert'] = 'simple assertion';
$string['leaf_backref'] = 'backreference';
$string['leaf_charset'] = 'character set';
$string['leaf_charset_error'] = 'incorrect character set';
$string['leaf_charset_except'] = 'any character except';
$string['leaf_charset_neg'] = 'negative character set';
$string['leaf_charset_one'] = 'character';
$string['leaf_control'] = 'control sequence';
$string['leaf_meta'] = 'meta-character or escape-sequence';
$string['leaf_options'] = 'modifier';
$string['leaf_subexpr_call'] = 'subexpression call';
$string['leaf_template'] = 'template without params';
$string['lexemhintpenalty'] = 'Penalty for the next lexeme hint';
$string['lexemhintpenalty_help'] = 'Penalty for getting the next lexeme hint. Typically will be greater than usual Moodle question penalty (which applies to any new attempt to answer question without hints) and next character one. These penalties are mutually exclusive.';
$string['lexemusername'] = 'Student-visible name for lexeme';
$string['lexemusername_help'] = 'Your students probably won\'t know that an atomic part of the language they learn is called <b>lexeme</b>. They may prefer to call it "word" or "number" or something. You may define a name for lexeme that would be shown on the "Hint next lexeme" button there.';
$string['lf_leaf_control'] = '';
$string['lnu_unsupported_node_error'] = 'Sequences \\L, \\l, \\N{name}, \\U, and \\u are not supported';
$string['mark_name_leaf_control'] = '';
$string['maxerrorsshowndescription'] = 'Maximum number of errors shown for each regular expression in the question editing form';
$string['maxerrorsshownlabel'] = 'Maximum number of errors shown';
$string['maxtypos'] = 'Typo limit';
$string['maxtypos_help'] = 'Upper typo limit for matching with typo detection. Exceeding the limit leads to incorrect match.';
$string['mergedassertion_option'] = 'You need to set full assertion support mode for using complex positive assertions.';
$string['mergemodeforassertion'] = 'Please select full assertion support in the settings. In fast mode {$a}';
$string['missing_brackets_for_g_node_error'] = '\\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number';
$string['missing_brackets_for_k_node_error'] = '\\k is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number';
$string['missing_callout_ending_node_error'] = 'Unclosed callout';
$string['missing_close_paren_node_error'] = 'Syntax error: missing closing parenthesis \')\' for the opening parenthesis in position {$a->colfirst}';
$string['missing_comment_ending_node_error'] = 'Syntax error: missing closing parenthesis for the comment in position from {$a->colfirst} to {$a->collast}';
$string['missing_condsubexpr_ending_node_error'] = 'Unclosed conditional subpattern name';
$string['missing_control_ending_node_error'] = 'Missing closing parenthesis after control sequence';
$string['missing_open_paren_node_error'] = 'Syntax error: missing opening parenthesis \'(\' for the closing parenthesis in position {$a->colfirst}';
$string['missing_subexpr_name_ending_node_error'] = 'Syntax error in subpattern name';
$string['missing_template_close_paren_node_error'] = 'Syntax error: missing template closing \'(?###>)\' for the template opening in position {$a->colfirst}';
$string['missing_template_open_paren_node_error'] = 'Syntax error: missing template opening \'(?###name<)\' for the template closing in position {$a->colfirst}';
$string['nla_node_assert'] = 'negative lookahead assert';
$string['nla_node_cond_subexpr'] = 'negative lookahead conditional subpattern';
$string['nlb_node_assert'] = 'negative lookbehind assert';
$string['nlb_node_cond_subexpr'] = 'negative lookbehind conditional subpattern';
$string['no_start_opt_leaf_control'] = '';
$string['noapproximateforhowtofixpichint'] = 'Typo analysis and typo limit above 0 are required. Try to enable typo detection or set typo limit to above zero. Selected matching engine could affect availability of typo section.';
$string['nocorrectanswermatch'] = 'No maximum grade regular expression matches the correct answer';
$string['node_alt'] = 'alternation';
$string['node_assert'] = 'lookaround assertion';
$string['node_concat'] = 'concatenation';
$string['node_cond_subexpr'] = 'conditional subpattern';
$string['node_error'] = 'syntax error';
$string['node_finite_quant'] = 'finite quantifier';
$string['node_infinite_quant'] = 'infinite quantifier';
$string['node_subexpr'] = 'subpattern';
$string['node_template'] = 'template with params';
$string['nohintgradeborderpass'] = 'No answer has a grade greater or equal the hint grade border. This disables hinting.';
$string['nosubexprcapturing'] = '{$a} engine doesn\'t support subpattern capturing, please remove placeholders (except {$0}) from the feedback or choose another engine';
$string['notation'] = 'Regular expression notation';
$string['notation_help'] = '<p>You can choose the notation to enter regular expressions. If you just want to write a regular expression, please use the default, <b>Regular expression</b> notation which is very close to PCRE, but has additional error-proof capabilities. It will ignore line breaks in you expressions, allowing mild formatting.</p><p><b>Regular expression (extended)</b> notation was created for easier handling of large expressions. It will ignore non-escaped whitespace characters, that are not inside character class, and will treat as comment anything from non-escaped # to the end of string. It is equivalent to PCRE_EXTENDED option and PHP "x" modifier.</p><p><b>Moodle shortanswer</b> notation allows you to use preg as a usual Moodle shortanswer question with the hinting capability - with no need to understand regular expressions. Just copy you answers from shortanswer question. The \'*\' wildcard is supported.</p>';
$string['notation_mdlshortanswer'] = 'Moodle shortanswer';
$string['notation_native'] = 'Regular expression';
$string['notation_pcreextended'] = 'Regular expression (extended)';
$string['objectname'] = 'question';
$string['onceonly_node_subexpr'] = 'once-only subpattern';
$string['pathtodotempty'] = 'Can\'t draw {$a->name}: path to dot of graphviz is empty. Please ask your administrator to install <a href="http://www.graphviz.com">graphviz</a> and specify path to it using the \'pathtodot\' option at Administration > Server > System Paths';
$string['pathtodotincorrect'] = 'Can\'t draw {$a->name}: path to dot of graphviz is incorrect or dot can not be executed. Please ask your administrator to check if <a href="http://www.graphviz.com">graphviz</a> is installed and \'pathtodot\' option is correct at Administration > Server > System Paths';
$string['php_preg_matcher'] = 'PHP preg extension';
$string['pla_node_assert'] = 'positive lookahead assert';
$string['pla_node_cond_subexpr'] = 'positive lookahead conditional subpattern';
$string['plb_node_assert'] = 'positive lookbehind assert';
$string['plb_node_cond_subexpr'] = 'positive lookbehind conditional subpattern';
$string['pluginname'] = 'Regular expression';
$string['pluginname_help'] = '<p>Regular expressions are a form of writing patterns to match different strings. You can use it to verify answers in two ways: an expression to match with full (usually correct) answer, or an expression to match a part of the answer (which can be used, for example, to catch common errors and give appropriate comments).</p><p>This question uses the PHP perl-compatible regular expression syntax as the default notation. There are many tutorials about creating and using regular expression, here is one <a href="http://www.phpfreaks.com/content/print/126">example</a>. You can find detailed syntax of expression here: <a href="http://www.nusphere.com/kb/phpmanual/reference.pcre.pattern.syntax.htm">php manual</a>. Note that you should neither enclose regular expression in delimiters nor specify any modifiers - Moodle will do it for you.</p><p>You can also use this question as the advanced form of shortanswer with hinting, even if you don\'t know a bit about regular expressions! Just select <b>Moodle shortanswer</b> as notation for your questions.</p>';
$string['pluginname_link'] = 'question/type/preg';
$string['pluginnameadding'] = 'Adding a regular expression question';
$string['pluginnameediting'] = 'Editing a regular expression question';
$string['pluginnamesummary'] = 'Enter a string response from student that can be matched against several regular expressions. Shows to the student the correct part of his response. Using behaviours with multiple tries can give a hint by telling a next correct character or lexeme.<br/>You can use it without knowing regular expression to get hinting by using the \'Moodle shortanswer\' notation.';
$string['posix_class_outside_charset_node_error'] = 'POSIX classes are not allowed outside character sets';
$string['possessivequant'] = 'Possessive quantifiers';
$string['privacy:metadata'] = 'The Preg question type do not store user data.';
$string['prune_leaf_control'] = '';
$string['quantifier_without_parameter_node_error'] = 'Syntax error: quantifier in position from {$a->colfirst} to {$a->collast} doesn\'t have an operand - nothing to repeat';
$string['questioneditingheading'] = 'Question editing settings';
$string['recursion_leaf_assert'] = 'fictive';
$string['recursion_node_cond_subexpr'] = 'recursive conditional subpattern';
$string['regex_handler'] = 'Regex handler';
$string['set_unset_same_modifier_node_error'] = 'Setting and unsetting the {$a->addinfo} modifier at the same time in position from {$a->colfirst} to {$a->collast}';
$string['simplification_equivalences_full_1'] = 'A simple assertions is superfluous because next to already have the same';
$string['simplification_equivalences_full_10'] = 'The two nested repetition can be replaced by one';
$string['simplification_equivalences_full_11'] = 'Quantifier "{$a->first}" equivalent "{$a->second}"';
$string['simplification_equivalences_full_12'] = 'Quantifier "?" It can be removed as an alternative may be the same emptiness';
$string['simplification_equivalences_full_13'] = 'The emptiness in the alternative, is superfluous because alternative and always coincides with emptiness';
$string['simplification_equivalences_full_14'] = 'Quantifier do not affect the operation of the regular expression, they can be removed';
$string['simplification_equivalences_full_2'] = 'Empty brackets do not affect the operation of a regular expression, you can remove';
$string['simplification_equivalences_full_2_1'] = 'Brackets do not affect the operation of a regular expression, you can remove';
$string['simplification_equivalences_full_3'] = 'Empty brackets do not affect the operation of the regular expression, as they do not have backreference or conditional subpatterns, they can be removed';
$string['simplification_equivalences_full_3_1'] = 'Brackets do not affect the operation of the regular expression, as they do not have backreference or conditional subpatterns, they can be removed';
$string['simplification_equivalences_full_4'] = 'Identical recurring part of the expression can be written in short';
$string['simplification_equivalences_full_5'] = 'The square brackets can be removed because the in which only one character';
$string['simplification_equivalences_full_6'] = 'It is better represented using square brackets';
$string['simplification_equivalences_full_7'] = 'You can make a %subexpression% of the brackets';
$string['simplification_equivalences_full_8'] = 'It is more convenient to write using the "?"';
$string['simplification_equivalences_full_8_1'] = 'Emptiness in the alternative can be removed, maybe. alternative and without it there can match with emptiness';
$string['simplification_equivalences_full_9'] = 'You can remove a quantifier "?" I have an alternative, adding to it an empty alternative';
$string['simplification_equivalences_short_1'] = 'Consecutive simple assertions';
$string['simplification_equivalences_short_10'] = 'Replacement of two quantifiers one';
$string['simplification_equivalences_short_11'] = 'Changing to an equivalent quantifier';
$string['simplification_equivalences_short_12'] = 'Excess quantifier "?"';
$string['simplification_equivalences_short_13'] = 'Excess emptiness in the alternative';
$string['simplification_equivalences_short_14'] = 'The useless quantifier';
$string['simplification_equivalences_short_2'] = 'The empty brackets "(?:)"';
$string['simplification_equivalences_short_2_1'] = 'The useless brackets "(?:)"';
$string['simplification_equivalences_short_3'] = 'Empty parentheses "()"';
$string['simplification_equivalences_short_3_1'] = 'The useless parentheses "()"';
$string['simplification_equivalences_short_4'] = 'Recurring sub-expression';
$string['simplification_equivalences_short_5'] = 'The extra square brackets';
$string['simplification_equivalences_short_6'] = 'Can lead to the equivalent character classes';
$string['simplification_equivalences_short_7'] = 'Introduction of alternative subexpressions';
$string['simplification_equivalences_short_8'] = 'Excess emptiness in the alternative';
$string['simplification_equivalences_short_8_1'] = 'Excess emptiness in the alternative';
$string['simplification_equivalences_short_9'] = 'Excess quantifier "?"';
$string['simplification_errors_full_1'] = 'Simple assertion "^" is superfluous, since it is not at the beginning of the regular expression';
$string['simplification_errors_full_2'] = 'Simple assertion "$" is superfluous, since it is not at the ending of the regular expression';
$string['simplification_errors_short_1'] = 'Excess simple assertion "^"';
$string['simplification_errors_short_2'] = 'Excess simple assertion "$"';
$string['simplification_tips_full_1'] = 'You may want to allow any whitespace (such as a tab), you have to use "\\s"';
$string['simplification_tips_full_2'] = 'You may want to allow any number of whitespace characters in this place, you have to use a quantifier "+"';
$string['simplification_tips_full_3'] = 'Parentheses allow the match to remember this portion of the expression. If you do not need the parentheses can be replaced by group "(?:)"';
$string['simplification_tips_full_4'] = 'You may want to allow any number of whitespace characters in this place, you have to use the quantifier "*"';
$string['simplification_tips_full_5'] = 'The expression matches any string';
$string['simplification_tips_full_6'] = 'Maybe you want to ignore the case, then this can be done using the option case-sensitivity off "(?i)"';
$string['simplification_tips_full_7'] = 'Not to copy this part, you can give it a name and call elsewhere';
$string['simplification_tips_full_8'] = 'Perhaps you should enable the "exact match" instead of "^" and "$" at the beginning and end of the expression';
$string['simplification_tips_full_8_alt'] = '"^" and "$" in the beginning and at the end of the statement is superfluous, because enabled "exact match"';
$string['simplification_tips_short_1'] = 'Expand the list of whitespace';
$string['simplification_tips_short_2'] = 'Increase the amount of whitespace';
$string['simplification_tips_short_3'] = 'The extra parentheses, for which there is no backreferences';
$string['simplification_tips_short_4'] = 'Only one whitespace';
$string['simplification_tips_short_5'] = 'The expression coincides with emptiness';
$string['simplification_tips_short_6'] = 'Use option (?i) instead of the character class with paired upper and lower case';
$string['simplification_tips_short_7'] = 'Repeated use of the expression';
$string['simplification_tips_short_8'] = 'Unnecessary asserts left and right';
$string['simplification_tool'] = 'Simplification of regular expression';
$string['simplification_tool_apply'] = 'Apply and next';
$string['simplification_tool_cancel'] = 'Cancel and next';
$string['simplification_tool_equivalence'] = 'Equivalences:';
$string['simplification_tool_error'] = 'Errors:';
$string['simplification_tool_help'] = 'Here you can see tips to simplify regular expressions if they are needed. Tips come of three types: equivalences (replacement of expression on more optimal equivalent expression), tips (include cases that could be missed) and errors (cases in which the regular expression matches any string or does not match with anything).';
$string['simplification_tool_tip'] = 'Tips:';
$string['skip_leaf_control'] = '';
$string['skip_name_leaf_control'] = '';
$string['slash_at_end_of_pattern_node_error'] = 'Syntax error: \\ at end of pattern';
$string['small_esc_z_leaf_assert'] = 'end of the string';
$string['subexpr_leaf_assert'] = 'fictive';
$string['subexpr_name_expected_node_error'] = 'Subpattern name expected';
$string['subexpr_node_cond_subexpr'] = '"subpattern"-conditional subpattern';
$string['subexpr_node_subexpr'] = 'subpattern';
$string['subexpression'] = 'Subpattern';
$string['syntax_tree_tool'] = 'Syntax tree';
$string['syntax_tree_tool_collapsing_mode'] = 'Collapsing mode';
$string['syntax_tree_tool_help'] = 'Here you can see syntax tree of you expression. Pressing the node of tree marks corresponding subtree, subgraph and corresponding part of description. You can also collapse / expand the nodes by turning on Collapsing mode.';
$string['then_leaf_control'] = '';
$string['tobecontinued'] = '...';
$string['too_large_fa'] = 'Regular expression is too complex to be matched by {$a->engine} due to the time and/or memory limits. Please try another matching engine, ask your administrator to <a href="{$a->link}">increase time and memory limits</a> or simplify you regular expression.';
$string['toolargequant'] = 'Too large finite quantifier';
$string['toomanyerrors'] = '.......{$a} more errors';
$string['truefalse_leaf_assert'] = 'fictive';
$string['typoanalysis'] = 'Typo analysis';
$string['typoanalysis_help'] = 'Typo analysis assumes, that student can have mistakes inside of answer.';
$string['typosfound'] = 'Typos found';
$string['typospenalty'] = 'Penalty for each encountered typo';
$string['typospenalty_help'] = 'Penalty for each encountered typo';
$string['ucp_leaf_control'] = '';
$string['unallowedhint'] = 'Selected hint not allowed due to restrictions in question settings. Please set "Allow {$a} hinting" to "yes" to allow it. Selected matching engine could affect availability of hints.';
$string['unclosed_charset_node_error'] = 'Syntax error: missing a closing bracket \']\' for the character set starting in position {$a->colfirst}';
$string['unexisting_subexpr_node_error'] = 'Subpattern "{$a->addinfo}" does not exist';
$string['ungreedyquant'] = 'Ungreedy quantifiers';
$string['unknown_control_sequence_node_error'] = 'Unknown control sequence: {$a->addinfo}';
$string['unknown_error_node_error'] = 'Unknown error';
$string['unknown_posix_class_node_error'] = 'Unknown POSIX class: {$a->addinfo}';
$string['unknown_template_node_error'] = 'Unknown template: {$a->addinfo}';
$string['unknown_unicode_property_node_error'] = 'Unknown Unicode property: {$a->addinfo}';
$string['unrecognized_pqh_node_error'] = 'Unrecognised character after (? or (?-';
$string['unrecognized_pqlt_node_error'] = 'Unrecognised character after (?<';
$string['unrecognized_pqp_node_error'] = 'Unrecognised character after (?P';
$string['unsupported'] = '{$a->nodename} in position from {$a->linefirst}:{$a->colfirst} to {$a->linelast}:{$a->collast} is not supported by {$a->engine}.';
$string['unsupported_modifier_node_error'] = 'Unknown, wrong or unsupported modifier(s): {$a->addinfo}';
$string['unsupportedmodifier'] = 'Error: modifier {$a->modifier} isn\'t supported by the {$a->classname}.';
$string['usecharhint'] = 'Allow next character hinting';
$string['usecharhint_help'] = 'In behaviours which allow multiple tries (e.g. adaptive or interactive) show students the \'Hint next character\' button that allows to get a one-character hint with applying the \'Hint next character penalty\'. Not all matching engines support hinting.';
$string['usehint_help'] = 'In behaviours which allow multiple tries (e.g. adaptive or interactive) show students the \'Hint next character\' button that allows to get a one-character hint with applying the \'Hint next character penalty\'. Not all matching engines support hinting.';
$string['usehowtofixpichint'] = 'Allow how to fix hiniting (image)';
$string['usehowtofixpichint_help'] = 'Shows the student, what he should do to make string correct. Typo analysis and typo limit above 0 are required.';
$string['uselexemhint'] = 'Allow next lexeme (word, number, punctuation mark) hinting';
$string['uselexemhint_help'] = '<p>In behaviours which allow multiple tries (e.g. adaptive or interactive) show students the \'Hint next word\' button that allows to get a hint either completing current lexeme or showing next one if the lexeme is complete with applying the \'Hint next lexeme penalty\'. Not all matching engines support hinting.</p><p><b>Lexeme</b> is an atomic part of the language: a word, number, punctuation mark, operator etc.</p>';
$string['utf16_leaf_control'] = '';
$string['utf8_leaf_control'] = '';
$string['wrong_template_params_count_node_error'] = 'Wrong template parameters count: {$a->addinfo->expected} expected, {$a->addinfo->given} given';
